[ { "title": "(LeetCode) 1911. Maximum Alternating Subsequence Sum", "url": "/posts/00009/", "categories": "Algorithm, LeetCode", "tags": "algorithm, leetcode, javascript, typescript, dynamic programming, dp, max, sum, subsequence, alternating", "date": "2022-07-12 09:00:00 +0900", "snippet": "문제 링크: https://leetcode.com/problems/maximum-alternating-subsequence-sum/문제 설명어떤 배열의 alternating sum (교차 합) 은 그 배열에서의 홀수 번째 원소는 더하고, 짝수 번째 원소는 뺀 값의 합을 의미한다. 예를 들어서, [4,2,5,3] 배열에 대한 교차 합은, (4+5)-(2+3)=4 가 된다.이러한 배경지식에서, 특정 배열 nums 가 주어졌을 때, nums 배열에서 뽑을 수 있는 임의의 subsequence (부분열) 들의 교차 합 중 최대 값을 구하는 것이 문제이다.부분열이라고 하면, 주어진 배열에서 일부 원소들을 제거는 하되, 원소들의 상대적인 순서는 유지한 새로운 배열을 말한다. 예를 들어서, [4,2,3,7,2,1,4] 배열에 대해서 [2,7,4] 는 부분열이라고 할 수 있지만, [2,4,2] 는 부분열이라고 할 수 없다.예시 입출력Input: nums = [4,2,5,3]Output: 7Explanation: It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7.Input: nums = [5,6,7,8]Output: 8Explanation: It is optimal to choose the subsequence [8] with alternating sum 8.Input: nums = [6,2,1,2,4,5]Output: 10Explanation: It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10.주어지는 nums 배열에 대한 제한사항은 아래와 같다.Constraints:- 1 &lt;= nums.length &lt;= 105- 1 &lt;= nums[i] &lt;= 105나의 해답우선 이 문제는 Bruteforce 하게 풀기에는 너무 많은 값을 체크해야 한다. nums.length 를 n 으로 잡으면, nums 배열의 부분열은 nC1, nC2, nC3, … nCn 만큼 경우의 수가 존재하기 때문에 이들에 대한 alternating sum 을 다 구해서 최대값을 구해야 한다. 당연히 이 것은 정답을 내뱉을 수는 있으나 시간 복잡도 상 매우 비효율적인 풀이가 된다.좀 더 쉽게 풀 수 있는 방법이 있는데, 각 원소가 부분열의 홀수번째 원소로 올 경우의 정답과 짝수번째 원소로 올 경우의 정답을 기록해두고, 그 값을 이용해서 동적 계획법 (Dynamic Programming) 을 통해 풀이하는 것이다. 각 원소마다 두 개의 정답을 저장하여 memoization 기법을 사용한다. 각 원소가 부분열의 홀수번째 원소로 올 경우에 대한 정답, 짝수번째 원소로 올 경우에 대한 정답을 저장한다.이렇게 하고 나면, 동적 계획법 풀이를 위한 점화식을 떠올려야 할텐데, 마지막 원소가 부분열의 홀수번째 원소로 오려면, 그 직전 원소는 짝수번째 원소로 와야 하며, 반대 경우도 마찬가지가 된다. 즉, 아래와 같은 점화식을 세울 수 있다. (슈도코드로 작성) f(nums) = nums 의 마지막 원소 nums[n-1] 값이 부분열의 홀수번째 원소가 될 경우의 nums 부분열의 최대 교차합p(nums) = nums 의 마지막 원소 nums[n-1] 값이 부분열의 짝수번째 원소가 될 경우의 nums 부분열의 최대 교차합f(nums) = max(f(nums[0:n-1]), p(nums[0:n-1]) + nums[n-1])p(nums) = max(p(nums[0:n-1]), f(nums[0:n-1]) - nums[n-1])즉, 두 개의 점화식이 서로 크로스하면서 계속 memoization 을 활용하며 최종적으로 f(arr), p(arr) 을 구할 수 있고 이 둘 중의 최대값이 정답이 된다. 그런데, 최대값은 무조건 f(arr) 일 수 밖에 없는데, 모든 원소는 양수이기 때문에, 덧셈의 대상 (홀수번째 원소) 이 하나라도 더 많아야 값이 더 커지게 된다.이것을 그대로 Typescript 코드로 옮기면 아래와 같다.나의 해답 코드 1function maxAlternatingSum(nums: number[]): number { const memo = new Array(nums.length).fill({}).map(o =&gt; [0, 0]); memo[0][0] = nums[0]; for (let i = 1; i &lt; nums.length; i++) { memo[i][0] = Math.max(memo[i - 1][0], memo[i - 1][1] + nums[i]); memo[i][1] = Math.max(memo[i - 1][1], memo[i - 1][0] - nums[i]); } return memo[nums.length - 1][0];};memo 라는 변수는 n x 2 배열인데, memo[i][0] 의 경우 nums[i] 가 부분열의 홀수번째 원소일 경우의 정답, nums[i][1] 의 경우 nums[i] 가 부분열의 짝수번째 원소일 경우의 정답이다.우선 첫번째 원소의 경우 무조건 홀수번째 원소가 될 수밖에 없다. 자기 자신만으로 이뤄진 부분열 밖에 만들수 없기 때문이다. 그래서 초기화는 memo[0][0] = nums[0] 으로 충분하다.그리고 memo[i][0] 의 경우 기존의 memo[i-1][0] 을 그대로 계승하되 (해당 인덱스의 원소가 부분열로 포함 안되는 경우도 감안), 직전 원소가 짝수번째인 케이스는 반드시 마지막 원소인 nums[i] 가 부분열에 포함되야만 교차합이 커지게 된다. (모든 원소가 양수이므로 부분열은 반드시 홀수 갯수를 가져야만 교차합이 커지게 된다.) 이러한 이유로, memo[i][0] 은 memo[i-1][0] 혹은 memo[i-1][1] + nums[i] 중 큰 값이 정답이 된다. memo[i][1] 도 거의 비슷한 맥락으로 이해할 수 있다.또한 위에서 언급한 것처럼, 모든 원소가 양수이기 때문에 가장 마지막 원소가 짝수번째 원소로 오는 케이스보다는 홀수번째 원소로 오는 케이스에서 교차합이 더 커지게 된다. (홀수번째 원소는 더하기를 하므로) 최종적으로는 memo[nums.length - 1][0] 이 정답이 된다. 굳이 Math.max(...memo[nums.length-1]) 을 할 필요가 없다는 것이다.나의 해답 코드 2위 방식대로 풀어도 충분히 문제는 효율적으로 잘 풀게 되었다. 그런데 좀 더 효율적으로 풀 수 있는 방법은 없을까 고민이 되었다. 일단, 점화식 자체가 바로 직전의 memoization 만을 활용하기 때문에 굳이 memo 라는 변수를 n x 2 만큼 다 가지고 있을 필요가 없다고 느꼈다. 즉, 공간 복잡도에서 좀 더 개선의 여지가 있다고 느꼈다.공간 복잡도를 좀 더 개선한 새로운 코드를 아래와 같이 작성해보았다.function maxAlternatingSum(nums: number[]): number { let resultOdd = 0; let resultEven = 0; for (let i = 0; i &lt; nums.length; i++) { resultOdd = Math.max(resultOdd, resultEven + nums[i]); resultEven = Math.max(resultEven, resultOdd - nums[i]); } return resultOdd;};resultOdd, resultEven 은 위에서 언급한 memo[i][0], memo[i][1] 과 같은 개념이다. 특정 인덱스까지의 배열에 대한 부분열의 교차합을 구할 때, 해당 인덱스의 원소가 홀수번째가 될 경우와 짝수번째가 될 경우에 대한 최대 교차합을 의미한다.resultOdd 는 기존의 resultOdd 를 계승하되, 이전 resultEven 값에 현재 인덱스의 원소값을 더한 값과 비교하여 최대값을 채택하게 된다. 의미상으로는 위 코드와 완전히 동일하다. 유일한 차이는 memo 라는 변수를 n x 2 배열로 만들었느냐, 아니면 계속 반복되는 memoization 표현을 변수 2개만으로 풀어나갔냐의 차이 뿐이다.GitHub 에서의 위 소스 코드 위치: https://github.com/jeongmincha/solving-algorithm/blob/master/leetcode/medium/1911-maximum-alternating-subsequence-sum.ts" }, { "title": "(LeetCode) 1072. Flip Columns For Maximum Number of Equal Rows", "url": "/posts/00008/", "categories": "Algorithm, LeetCode", "tags": "algorithm, leetcode, javascript, typescript, flip, column, row, matrix, maximum, max", "date": "2022-07-09 09:00:00 +0900", "snippet": "문제 링크: https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/문제 설명 m x n 크기의 이차원 이진수 배열이 주어진 상황에서, 아무 열 (column) 이나 선택해서 그 열의 원소들을 플립할 수 있다. 플립을 여러 번 한 후에 모든 원소가 같은 숫자인 행 (row) 의 최대 갯수를 구하라.입/출력 예시Input: matrix = [[0,1],[1,1]]Output: 1Explanation: After flipping no values, 1 row has all values equal.Input: matrix = [[0,1],[1,0]]Output: 2Explanation: After flipping values in the first column, both rows have equal values.Input: matrix = [[0,0,0],[0,0,1],[1,1,0]]Output: 2Explanation: After flipping values in the first two columns, the last two rows have equal values.나의 풀이https://github.com/jeongmincha/solving-algorithm/blob/master/leetcode/medium/1072-flip-columns-for-maximum-number-of-equal-rows.tsfunction maxEqualRowsAfterFlips(matrix: number[][]): number { function arrayEquals(arr1: number[], arr2: number[]) { return !(arr1 &gt; arr2 || arr1 &lt; arr2); } const m = matrix.length; const n = matrix[0].length; let counter: { [k: string]: number } = {}; for (let i = 0; i &lt; m; i++) { let flippedCurrentRow = ''; for (let j = 0; j &lt; n; j++) { flippedCurrentRow += 1 - matrix[i][j]; } const currentRow = matrix[i].join(''); counter[currentRow] ??= 0; counter[flippedCurrentRow] ??= 0; counter[currentRow] += 1; counter[flippedCurrentRow] += 1; } return Math.max(...Object.values(counter));};이 문제를 풀기 위한 아이디어를 생각하는 과정을 설명해 보겠다.우선, 특정 열을 플립하여 최종적으로 특정 행이 모든 원소가 같으려고 하면, 그 행들은 서로 완전히 같거나 혹은 원소들이 모두 플립된 행과 같아야 한다. 이게 무슨 말이냐 하면, 예를 들어서 수많은 행 중 2개의 행이 아래와 같다고 가정하자....[0,0,1,0,0]...[1,1,0,1,1]...이 경우에는 다른 행은 우선 넘어가고, 이 2개의 행은 어떻게든 모든 원소가 같은 행으로 만들 수 있다. 왜냐하면, 세 번째 열을 플립하면 되기 때문이다. 즉, 전체 행을 뒤져보면서, 서로 완전히 같거나 혹은 플립된 형태로 같은 행들의 갯수가 정답이 된다.자, 이제 각 행을 서로 비교하는 방식으로 구현할 수 있을 텐데, 이렇게 하면 O(m^2) 의 시간 복잡도를 가지게 된다. 좀 더 시간 복잡도를 줄일 수는 없을까?각 행을 서로 비교하는 것보다는, 특정 행이 등장했을 때, 그 행의 갯수를 +1 씩 하는 카운터 해시를 만들면 좋을 것이다. 즉, 각 행을 1번씩 순회하면서, 그 행 자체와 그 행을 플립한 행을 카운터값에 +1 하면서 순회하게 된다면, O(m) 의 시간 복잡도로도 문제를 해결할 수 있다.위 설명을 토대로 코드를 좀 더 설명해보자면, counter 라는 변수를 만들었고, 이 변수는 행을 문자열화한 것을 key 로, 그 행이 등장한 횟수를 value 로 갖는 해시 맵 같은 역할을 한다.예시 입출력 중, matrix = [[0,0,0],[0,0,1],[1,1,0]] 케이스에서 반복문을 돌리고 나면, counter 변수는 아래와 같아진다.count = {'000': 1, '111': 1, '001': 2, '110': 2}// 첫 번째 행 000 -&gt; 000 과 111 에 대해서 +1// 두 번째 행 001 -&gt; 001 과 110 에 대해서 +1// 세 번째 행 110 -&gt; 110 과 001 에 대해서 +1위와 같은 counter 변수에서 값들 중 최대값을 찾으면 된다. 이 값이 열들을 플립했을 때 완전히 같거나 플립한 형태로 같은 최대 행의 갯수가 된다.결과문제를 푼 것만 해도 기분이 좋지만, 시간복잡도 와 공간 복잡도 두 관점 모두 에서 전체 submission 중 최고로 좋은 점수를 받았다!가끔 둘 중 하나에 대해서 100% 를 달성한 경우는 있었지만, 둘 다 100% 를 달성한 경우는 처음이다. 별거 아니지만 뭔가 뿌듯하고 기쁘다. 다른 문제를 풀 때도 이런 식으로 100% 에 가까운 숫자를 달성할 수 있게 되면 좋겠다." }, { "title": "(BOJ 9078) 이웃하는 두 수만 정렬하는 문제", "url": "/posts/00007/", "categories": "Algorithm, BOJ", "tags": "algorithm, sorting, boj, python, 백준, 정렬", "date": "2022-07-07 09:00:00 +0900", "snippet": "문제: https://www.acmicpc.net/problem/9078문제주어진 숫자 열을 정렬하는데, 사용할 수 있는 연산은 이웃하는 두 숫자를 다른 두 수 사이나 숫자열의 맨 앞 혹은 맨 뒤에 끼워 넣는 것 뿐이다. 즉, 한 번에 숫자를 하나씩 옮기는 것이 아니라, 이웃하는 숫자를 두 개씩 묶어서 옮긴다. 4 1 5 3 2 의 경우 다음과 같이 정렬할 수 있다.4 1 5 3 2 → 3 2 4 1 5 → 3 4 1 2 5 → 1 2 3 4 5그러나 2 1 3 의 경우에는 어떻게 하더라도 정렬할 수 없다.이와 같이 입력으로 1에서 N까지의 서로 다른 N의 정수로 구성된 숫자 열이 주어졌을 때, 그것이 위의 연산만으로 정렬가능한지 여부를 결정하는 프로그램을 작성하시오.입력입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 20)가 주어진다. 각 테스트 케이스는 두 줄로 이루어져 있다. 첫째 줄에는 정수 N(1 ≤ N ≤ 100)이 주어지고, 둘째 줄에는 N개의 정수가 공백을 사이에 두고 주어진다.출력각 테스트 케이스에 대해서 정렬 가능하면 YES를, 아니면 NO를 한 줄에 하나씩 출력한다.나의 해답https://github.com/jeongmincha/solving-algorithm/blob/master/BOJ/9078.pyfor test_case in range(int(input())): n = int(input()) lst = input().split() count = 0 for i in range(n): for j in range(i+1, n): if lst[i] &gt; lst[j]: count += 1 if count % 2 == 0: print('YES') else: print('NO')설명이미 정렬이 가능한 배열에 대해서 2개의 원소가 추가로 들어올 때, 그 원소들도 이미 정렬된 상태여야만 전체 배열이 정렬 가능한 상태라고 말할 수 있다.예를 들어서 1이라는 원소 하나만 있는 배열은 이미 정렬된 것이므로 23을 앞에 붙이나 뒤에 붙이나 결국 최종 배열은 정렬 가능한 상태가 된다.(123 or 231)그런데 이 때, 순서를 바꾸게 되면서 원소 간의 대소 변화도 짝수만큼 변화하게 된다. 이 값을 명확하게 하기 위해서, count 라는 변수를 사용했고, 이 변수는 각 원소와 그 뒤 원소들을 비교하여 해당 인덱스의 원소가 큰 경우의 수를 합한 값이다. 123의 경우, 이미 정렬이 완료되어 있으므로 count 는 0 이 된다. 312의 경우, count 는 2가 된다.즉, 이미 정렬이 되어 있는 배열의 경우 count 값이 0이 되고, 그 상태에서 2개의 원소들을 움직일 때마다 count 는 짝수만큼 변화하게 되므로, count 가 짝수인 경우에만 정렬 가능한 상태라고 말할 수 있는 것이다.이에 따라서 count 값을 구하고 그 경우가 짝수일 때 YES, 홀수일 때 NO 를 반환하도록 구현하면 해결이 된다.※ 기존 블로그 글: https://thinkpro.tistory.com/162 (2020-07-14)" }, { "title": "전문연구요원 전직 정리 2. 전직 승인을 받기 위한 과정", "url": "/posts/00006/", "categories": "일상, 정보", "tags": "전문연구요원, 석사, 병역특례, 병특, 복무상황부, 병역지정업체, 승인, 승인전직, 채용동의서, 전직, 전직신청서", "date": "2022-07-03 09:00:00 +0900", "snippet": "앞선 포스팅에서 승인전직을 받기 위한 조건/케이스를 간단하게 다뤄보았다. 이 포스팅에서는 어떤 과정/단계를 밟아서 전직승인이 되는지 최대한 아는대로 자세히 말해보겠다.각 단계의 주체를 [ ] 로 표현하였다. (주체: 본인, 새 회사, 현 회사, 병무청) [본인] 옮겨가고 싶은 회사를 탐색한다. [본인] 해당 회사가 “전문연구요원 병역지정업체”에 해당하는지를 확인한다. https://work.mma.go.kr/caisBYIS/search/byjjecgeomsaek.do 여기서 전문연구요원 필터링을 걸어서 검색이 잘 되면 해당 업체는 전문연구요원 병역지정업체라고 볼 수 있다. 여기서, 대소문자 영문자, 한문 등을 완벽하게 일치하게 작성해야만 검색이 되므로 주의하자. 참고로 전문연구요원과 산업기능요원은 완전히 다른 것이므로, 둘 다 안되는 경우, 둘 중 하나만 되는 경우, 둘 다 되는 경우 등이 있다. 그러므로, 본인이 전문연구요원이라면 전문연구요원을 선택한 후에 검색! [본인] 해당 회사에 지원과정을 거쳐 최종합격을 받는다. (이하 새 회사) [본인, 새 회사] 최종합격을 받은 후 통상 오퍼레터를 받게 될것이고, 오퍼레터와 함께 채용동의서를 요구한다. 참고로 채용동의서 안에는 내가 작성해야하는 부분도 있다. (성명, 주민등록번호, 아버지 성명, 어머니 성명, 편입일자, 역종 등) 새 회사가 채용 동의서를 작성할 때 이 정보들을 요구할 것이다. [본인] 채용동의서를 받은 후, 현 회사에 퇴직의사를 밝힌다. 퇴직의사를 밝히는 과정은 보통 실무진 직속 상사(팀장 및 직속 조직장) 에게 보고하는 것을 말하고, 퇴사결재를 한다는 것은 실제 더 그 위의 인사담당자 및 임원진에게까지 결재 보고를 하는 것을 말한다. 여기서 승인 전에 퇴직의사를 밝히는 이유는 통상적으로 회사에 퇴직 의사를 밝히고 실제 퇴직일은 약 1달 정도 후가 되는 경우가 많기 때문이다. [본인, 현 회사] 본인이 전직신청서를 작성한다. 전문연구요원 담당하시는 인사담당자분들이 전직신청서 서식을 가지고 계실 것이다. 전직신청서에는 현 회사, 개인 복무 정보, 그리고 새 회사에 대한 작성이 필요하므로 본인이 작성하고 현 회사 인사담당자에게 넘겨준다. 현 회사 인사 담당자가 해당 신청서를 확인하고 업체 장의 날인 (현 회사) 을 찍어줄 것이다. [본인] 채용동의서, 전직신청서, 그 외 필요 서류 (개인 복무상황부 등) 등을 현 회사의 인사담당자에게 전달한다. 여기서 그 외라 하면 보통은 개인 복무상황부를 말한다. 출퇴근기록표라고 보면 된다. 출퇴근기록 및 (출퇴근 안한날에 대한 소명이 필요하므로) 휴가기록 이 포함되어야 하는데, 휴가기록을 일일이 대신 작성해주시는 천사 인사담당자님은 보통 거의 없으므로 통상적으로는 휴가기록을 작성해달라고 요청하실거다. 그러면 말을 잘듣고 작성해드려서 복무상황부를 채우는데 도움을 드리자. [현 회사] 현 회사 인사담당자가 전직에 필요한 서류들을 병무청에 전달한다. 총 3개의 서류가 전달될 예정이다. (전직신청서 / 채용동의서 / 개인복무상황부) [병무청] 전직승인을 허가한다. [본인, 현 회사] 퇴직일이 반드시 전직승인일 이후가 되도록 한다. 그리고 퇴사를 한다. [본인, 새 회사] 새 회사에 입사한다. 과정 9번 (병무청 승인) 이후에 반드시 14일 이내로 새 회사에 입사하여야 한다. 참고로, 병무청 승인이 늦어지는 경우 현 회사의 퇴직일 / 새 회사의 입사일을 어느 정도 미룰 수 있도록 부탁드려야 한다. (승인 후 14일 이내 입사가 되도록) 이것으로 단계가 끝난다. 여기서 궁금한것은 아무래도 퇴직일과 관련된 영역일 것이다.퇴직 자체는 전직 승인 후에 이뤄져야 하는데, 문제는 통상적인 회사는 퇴직 전 한달 전에 사실을 알릴 것을 요구한다. 즉, 전직 승인 전에 현 회사에 퇴직 의사를 밝혀야 한다는 것이다.채용 동의서 확보 &gt; 실무진 퇴직 의사 표명 &gt; 퇴직 결재/보고/상신 &gt; \"병무청 승인\" &gt; 퇴사 &gt; 새 회사 입사가 될텐데, 병무청 승인이라는 걸림돌이 있으므로, 퇴직 의사 표명 후에 퇴사 및 새 회사 입사가 불가능해질 수도 있는 것이다. 승인은 어지간하면 조건만 맞으면 해주는 것 같으나, 몇몇 경우와 비전공자라던가 새 회사와 현 회사 사이에 업종이 맞지 않는다거나 하면 승인 불허가 날 수 있다. 즉 마음을 마냥 놓을수는 없다.즉, 최악의 경우 퇴직 결재 승인됬는데 병무청 승인 불허되버린 경우다. 그렇지만, 이런 경우가 충분히 있을수 있고 이것은 우리의 잘못이 아니기 때문에 이 상황을 확실하게 현 회사가 인지하고 이 경우에는 퇴사를 무를수 있게 해줘야 한다. 보통 회사랑 사이가 심하게 나쁜게 아니라면 그렇게 해준다. 그렇기 때문에 전문연구요원 담당하시는 인사담당자분과 이야기를 잘 해둬야 한다. 병무청 승인 후 “퇴직 결재/보고/상신~승인” 까지 현 회사가 엄청 빠르게 해 줄 것을 보장받기 (14일 내로 해줘서 새 회사 입사에 무리없게끔) 또는 1달 전 (병무청 승인 전) 에 퇴사 결재를 먼저 올리고 최악의 경우, 퇴직일 변경 혹은 퇴직 자체를 취소 (병무청 승인 불허 경우) 할 수 있는 상황을 보장받기 보통은 그래도 최소한 2번은 하게 해준다. 다만, 당연히 그럴거라 믿고 단독행동하면 안되고 이 과정에서 제일 중요한 것은 각 회사의 인사담당자랑 충분한 커뮤니케이션과 상황 공유이다. 필자가 다녔던 회사의 경우 인사담당자께서 통상 2번으로 하신다고 하여서 나도 2번으로 처리하였다. 만약 2번으로 한다고 가정하면 채용 동의서 수령 후 퇴직 의사 표명 및 결재를 올리고, 퇴직일로 합의하였던 일자 약 10일 전쯤부터 인사담당자가 병무청에 서류를 보내어 퇴사/입사에 문제없게끔 승인 처리를 시도한다. 그 후에 승인이 됬다면 문제가 없는 거고 승인이 안됬다고 하면 그 사이에 퇴사를 유보/취소하는 처리를 함으로써 다시금 원래 회사를 계속 다닐 수 있게 되는 것이다. 아시다시피 이것은 회사가 엄청 나를 잘 봐준 것이므로 회사랑 사이가 너무 안좋은 경우 쉽지 않을 수 있다. 어쨌든, 미리 말을 잘 받아놓고 시도하는게 좋다.아예 날짜로 말해주자면, (날짜는 예시이다.) 1월 1일 채용동의서 수령 1월 1일 실무진 직속 상사에게 퇴사 의사 표현 1월 1일 퇴사 결재/보고/상신 1월 20일 병무청 승인 관련 서류 전송 (by 현 회사 인사담당자) 1월 25일 병무청 전직 승인 결정 1월 25일 퇴사 (퇴사 결재를 올린 날과 한달이 안되었으나 현 회사와 딜을 했다는 가정. 한달 뒤에 퇴사하기로 했다면 이 값은 2월 1일이 된다.) 2월 1일 입사 (14일을 풀로 기다리지 않고 7일 뒤에 입사한 케이스) 이런식이 될거다.개인적인 경험으로는 굳이 14일 풀로 하는 것보다 혹시 모를 상황을 대비해 퇴직일과 입사일을 1주일 정도로 떨어뜨려 생각해 두고 진행하는게 제일 베스트라고 생각한다.※ 기존 블로그 글 연결: https://thinkpro.tistory.com/166 (2021.06.07)" }, { "title": "전문연구요원 전직 정리 1. 나는 승인전직을 할 수 있는가?", "url": "/posts/00005/", "categories": "일상, 정보", "tags": "전문연구요원, 병역특례, 병특, 당연전직, 대체복무, 대학원, 병역지정업체, 승인전직, 전직", "date": "2022-07-03 09:00:00 +0900", "snippet": "이미 좋은 포스팅 글이 많지만, 나 스스로 정리하기 위한 목적으로 글을 한 번 써본다.전문연구요원 전직이란전문연구요원 전직이라 함은 전문연구요원의 신분으로써 현 병역지정업체가 아닌 다른 병역지정업체로 가서 일을 하게 되는 것을 말하는데, 여러 가지 케이스가 있겠으나 1) 회사 or 2) 대학원 박사과정 이고, 여기서는 회사에서 다른 회사로 가는 케이스에 대해서만 주로 다뤄보려고 한다.그 전에 전문연구요원 전직은 1) 당연전직, 2) 승인전직으로 나뉘어지며, 당연전직은 회사가 망했다거나 하는 등 내 의사랑 상관없이 당연히 옮길 수밖에 없는 상황에 특별한 제약없이 쉽게 할 수 있는 전직을 말하고, 승인전직은 승인이 필요한 전직을 말하는데, 통상적으로 개인 의사로 인한 전직을 의미한다.전문연구요원 전직 &gt; 승인 전직그래서 이 “승인전직” 안에서도 여러가지 해당사항이 있으나, 가장 대표적인 케이스가 첫번째로 명시되어 있는 1년 6개월 이상 한 병역지정업체에서 근무한 경우이다. 여기서 재밌는 건, 대학원 박사과정 전문연 중에 회사로 가려는 경우 굳이 1년 6개월이라는 조건을 맞출 필요는 없고, 중소기업 외 연구기관에서 중소기업부설로 가려는 경우에도 1년 6개월의 조건은 필요없다. 즉, 현재 가려는 곳이 중소기업부설 연구기관으로 가고자 한다면 이미 중소기업 부설 연구기관에 다니고 있는 게 아닌 이상 이 1년 6개월의 조건을 신경 쓸 필요가 없다.원래는 1년 6개월의 기간은 있어야만 티오를 얻고 다른데로 자유롭게 떠날수 있는 줄 알고 있었는데, 본인이 대학원 박사학위과정의 전문연구요원이거나, 중소가 아닌 곳에서 중소로 가려는 경우 (기업규모 를 낮추는 경우) 는 이 조건을 지키지 않아도 된다. 확실한 참고: 병무청 링크 https://www.mma.go.kr/contents.do?mc=mma0000765어쨌든, 그래도 대다수 분들은 또 1년 6개월을 반드시 지켜야만 하는 경우가 많을 것이다. 지금 회사 규모 이상으로 가고 싶은 경우도 있을테고, 아니면 이미 중소기업 부설 연구소에 다니고 있다면 어차피 다른 중소기업을 가고 싶어도 1년 6개월은 지켜야 한다. 병역지정업체 검색을 통해 기업 규모를 알 수 있다 내가 다니고 있는 회사/ 다닐 회사가 어떤 기업규모가 어떤지 알고 싶다면 “전문연구요원 병역지정업체”를 검색해보면 된다. https://work.mma.go.kr/caisBYIS/search/byjjecgeomsaek.do기업에 대해서는 내가 아는 한, 대기업 &gt; 중견 &gt; 중소 &gt; 벤처 와 같은 형태로 기업 규모가 명세되어 있는 것으로 안다.예를 들어, 네이버를 검색해보았는데, 위 사진을 보면 알 수 있듯이, 네이버의 경우 대기업 부설 연구소로 전문연구요원을 받고 있는걸 볼 수 있다. 여기서, 병역지정업체 검색 사이트에서 정확히 대/소문자 한글/영문을 잘 지켜서 검색해야 한다. 네이버의 경우 정확히 “Naver”라고 검색해야만 뜬다. “NAVER”라던지 “네이버”라던지 “naver”라던지는 안된다.어쨌든, 결론을 내리자면, 전문연구요원 승인 전직을 위해서는 아래 두 조건 중 하나를 만족하면 되는 것이다. 1) 1년 6개월 조건을 만족시켰거나, 또는 2) 1년 6개월 조건이 없더라도 승인전직이 가능한 상황 (기업규모 줄이는 이직 or 대학원에서 도망치기…) 자, 이제 승인전직을 위한 조건은 준비가 되었다.승인전직의 프로세스에 대해서는 다음 포스팅에서 다뤄보고자 한다.※ 기존 블로그 글 연결: https://thinkpro.tistory.com/165 (2021.06.07)" }, { "title": "Completeness (완전성) 과 Soundness (건전성)", "url": "/posts/00004/", "categories": "Computer Science", "tags": "computer science, completeness, soundness, algorithm, 컴퓨터, 과학, 공학, 완전성, 건전성", "date": "2022-07-03 09:00:00 +0900", "snippet": "이 문서에서 말하는 Completeness, Soundness 는 알고리즘 혹은 입출력 시스템에 대한 것이다. Completeness: 모든 정답 사례를 찾아낼 수 있다. Soundness: 어떠한 오답 사례도 정답 사례로 잘못 판단하지 않는다. 어떠한 알고리즘이 완전하다, 건전하다라고 말하는 것을 이해하기 위해서는 true, false &amp; positive, negative 개념을 먼저 이해하면 더 쉽게 이해할 수 있다. true positive = 참이라고 예측했고 실제로도 참인 경우 false positive = 참이라고 예측했으나 실제로는 거짓인 경우 false negative = 거짓이라고 예측했으나 실제로는 참인 경우 true negative = 거짓이라고 예측했고 실제로도 거짓인 경우(맞췄으면 true, 틀렸으면 false, 알고리즘이 주장한 값이 참이면 positive, 거짓이면 negative 임)이걸 이해한 채로 예를 들어보겠다. A, B, C, D, E, F 라는 6명의 사람이 있고, A, B, C 는 거짓말 쟁이, D, E, F 는 정상인이라고 하자. 우리는 전체 사람들 중에서 정상인을 찾을 수 있는 알고리즘을 구현해야 한다.우리가 만든 알고리즘인 완전하려면 (Completeness), 이 알고리즘은 반드시 D, E, F 가 정상인임을 찾아낼 수 있어야 한다. 단, 이 것이 A, B, C 를 거짓말쟁이라고 지적할 수 있음을 의미하는 것은 아니다. 즉, 완전하지만 건전하지 않은 알고리즘이라면, A, B, C 중 한 명 이상을 정상인으로 잘못 판단하게 된다. (false positive)우리가 만든 알고리즘이 건전하려면 (Soundness), 이 알고리즘은 A, B, C 를 거짓말쟁이라고 잘못 판단하지 않는다. 단, 이 것이 D, E, F 기 모두 정상인이라고 밝힐 수 있음을 의미하지는 않는다. 즉, 건전하지만 완전하지 않은 알고리즘이라면, D, E, F 중 한 명 이상을 거짓말쟁이라고 잘못 판단하게 된다. (false negative)따라서, 알고리즘이 완전하면서도 건전하다면 (Completeness and Soundness), 어떠한 잘못된 판단을 내리지 않는다. Completeness Soundness 알고리즘의 출력 O O D E F 정상인, A B C 거짓말쟁이 (잘못된 판단 없음) O X A D E F 정상인, B C 거짓말쟁이 (A 에 대해서 false positive) X O E F 정상인, A B C D 거짓말쟁이 (D 에 대해서 false negative) ※ 기존 블로그 글 연결: https://thinkpro.tistory.com/163 (2020.07.14)" }, { "title": "Authentication (인증) vs Authorization (인가)", "url": "/posts/00003/", "categories": "Computer Science", "tags": "computer science, security, authentication, authorization, 공학, 과학, 권한, 권한부여, 인증, 인가, 컴퓨터", "date": "2022-06-29 09:00:00 +0900", "snippet": " Authentication (인증): who you are (당신은 누구인가) 누군가 자신을 A라고 말할때 그것이 사실인지 확인하는 과정 Authorization (인가): what you can do (당신이 무엇을 할 수 있는가) A 라는 사람이 특정한 행동을 수행할 때, 그 행동에 대한 권한이 있는지 확인하는 과정 즉, 인증은 진짜 그 사람이 맞는지, 그 서비스의 풀에 들어와 있는 사람이 맞는지를 확인하는 것이고, 인가는 서비스 안의 특정 행동이 가능한지를 확인하는 것이다. 예를 들어, 특정 사이트에 “로그인”하는 것은 “인증”이라고 보면 되고, 그 사이트의 어드민 페이지에 접근할 권한이 있는지 확인하는 것은 “인가”라고 보면 된다.※ 기존 블로그 글 연결: https://thinkpro.tistory.com/164 (2020.07.14)" }, { "title": "(LeetCode) 969. Pancake Sorting", "url": "/posts/00002/", "categories": "Algorithm, LeetCode", "tags": "algorithm, sorting, leetcode, selection sorting, javascript, typescript, 정렬, 선택 정렬, 알고리즘, 자바스크립트, 타입스크립트 릿코드", "date": "2022-06-26 09:00:00 +0900", "snippet": "문제 설명릿코드 (leetcode, 리트코드) 의 969 번째 문제는 Pancake Sorting 이라는 이름의 문제로, 팬케이크를 뒤집듯이 배열의 특정 구간만 뒤집는 것을 계속 반복했을 때, 최종적으로 전체 배열을 정렬시키도록 만들 수 있는지 물어보는 문제이다. 위 짧은 유튜브 영상을 보면 좀 더 쉽게 이해가 될텐데, 최종적으로 가장 작은 팬케이크가 맨 위에, 가장 큰 팬케이크가 맨 아래에 가도록 정렬이 되어야 하는 것이다.요구 입출력이러한 상황에서, 문제가 요구하는 명확한 입/출력을 말해보겠다. 문제 링크 에 들어가보면 아래와 같이 2가지 예제가 있다.Input: arr = [3,2,4,1]Output: [4,2,4,3]Explanation:We perform 4 pancake flips, with k values 4, 2, 4, and 3.Starting state: arr = [3, 2, 4, 1]After 1st flip (k = 4): arr = [1, 4, 2, 3]After 2nd flip (k = 2): arr = [4, 1, 2, 3]After 3rd flip (k = 4): arr = [3, 2, 1, 4]After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted.즉, 팬케이크를 플립하는 기준이 되는 숫자인 k 가 될 수 있는 값들의 배열을 반환하는 함수를 구현하면 되는 것이다. 여기서는, k 가 4,2,4,3 인 형태로 팬케이크 플립을 하면 최종적으로 배열은 1,2,3,4 와 같이 전체 정렬이 완성되기 때문에 4,2,4,3 은 정답이 된다.다만, 여러 가지 배열이 정답이 될 수 있다. 문제에서는 10 * arr.length 횟수보다 적은 플립으로 정렬했을 경우 정답으로 받아들인다고 작성되어 있다.Input: arr = [1,2,3]Output: []Explanation: The input is already sorted, so there is no need to flip anything.Note that other answers, such as [3, 3], would also be accepted.Solution이 문제를 풀 수 있는 방법은 다양하게 있겠지만, 일단 여기서는 가장 큰 원소 하나를 맨 뒤로 보내놓고, 그 앞 원소들만 정렬하는 것을 계속 반복함으로써 모든 배열 정렬하는 방법을 고려하였다.즉 쉽게 말하자면, 선택 정렬의 개념과 유사하게 풀었다고 보면 된다. 선택 정렬의 경우, 기본적으로 배열 중 가장 작은 원소를 ‘선택’해서 맨 앞에 있는 원소와 자리바꿈을 하고, 앞으로 이동된 원소들은 이미 정렬된 상태이므로, 그 뒤 배열들에 대해서만 계속 정렬 과정을 진행함으로써 최종적으로는 모든 원소들이 정렬되도록 만드는 방법이다.이 문제를 풀 때에는 1) 우선 가장 큰 원소를 찾고, 2) 맨 앞에서 그 원소까지의 배열을 플립하고, 3) 다시 전체 배열을 플립함으로써 가장 큰 원소가 맨 뒤에 배치하도록 했다. 그리고 나면 맨 뒤에 있는 원소들은 이미 정렬이 된 것이므로 다음 차례에서 굳이 고려하지 않고 그 앞에 있는 배열들에 대해서만 1~3 과정을 계속 반복해주면 된다.내가 작성한 솔루션 코드는 아래와 같다.function findMaxIndex(arr: number[]): number { let idx; for (idx = 0; idx &lt; arr.length; idx++) { if (arr[idx] === arr.length) { break; } } return idx;}function pancakeSort(arr: number[]): number[] { const flipIndices: number[] = []; let currentSize = arr.length; while (currentSize &gt; 1) { const maxIndex = findMaxIndex(arr.slice(0, currentSize)) + 1; if (maxIndex === 1) { arr = arr.slice(0, currentSize).reverse(); flipIndices.push(currentSize); } else if (maxIndex !== currentSize) { arr = [...arr.slice(0, maxIndex).reverse(), ...arr.slice(maxIndex)]; flipIndices.push(maxIndex); arr = arr.slice(0, currentSize).reverse(); flipIndices.push(currentSize); } currentSize -= 1; } return flipIndices;}pancakeSort() 함수가 실질적으로 제출해야 하는 함수이므로 이 함수 내용을 먼저 보자.currentSize 라는 변수는 아직 정렬되지 않은 부분의 길이를 결정하는 변수라고 보면 된다. 즉, 제일 처음에는 전체 배열의 길이가 되지만, 그 길이를 점차 1씩 줄여나가다가 최종적으로 1이 되는 시점에 모든 원소들이 정렬이 되었으므로 반복문을 멈추면 된다.maxIndex 라는 변수는 findMaxIndex 라는 함수의 값을 사용하였는데, 주어진 배열에 있는 원소들 중 가장 값이 큰 원소의 인덱스를 반환하는 함수를 따로 구현한 것이다. 여기서 왜 Math.max 같은 것을 쓰지 않는지 궁금할 수 있는데, 기본적으로 문제의 주어진 조건에서 각 원소는 1 ~ N 사이의 자연수들이 되기 때문이다. 따라서, 길이 N 인 배열에서 가장 큰 원소의 값은 당연히 N 이 된다. 그 값과 같은 위치가 바로 우리가 원하는 maxIndex 가 된다. (최대값 원소의 인덱스)자, 이제 maxIndex 라는 값이 가질 수 있는 케이스가 총 3가지가 있다. maxIndex 가 1 인 경우 (최대 원소가 맨 앞에 있는 경우) maxIndex 가 currentSize 인 경우 (최대 원소가 맨 뒤에 있는 경우) 그 외1번의 경우 최대 원소가 맨 앞에 있으므로 그 상태에서 즉시 전체 배열을 플립하면 된다. 2번의 경우 이미 최대 원소가 맨 뒤에 있으므로 아무것도 하지 않고 다음 차례를 진행하면 된다. 그 외인 3번의 경우에는 앞서 이야기한 것처럼, 맨 앞에서 최대 원소까지의 배열만 플립하고, 그 다음에 전체 배열을 플립하면 된다.정리이렇게, 팬케이크 정렬 문제를 풀어보았다. 선택 정렬과 비슷하게 풀면 된다는 아이디어를 찾을 수만 있다면 그렇게 어렵지는 않은 문제이기도 하며, 난이도는 미디움 (medium) 이다. 아이디어 자체를 잘 찾아서 적당히 잘 푼 것 같으나, 이번에는 뭔가 클린하고 이쁘게 작성은 못한 거 같다. 동작은 그대로 하되 좀 더 이쁘게 작성할 방법이 있다면 댓글로 알려주시면 감사하겠습니다. (배열쪽 저장하는 부분?)" }, { "title": "첫 번째 포스팅", "url": "/posts/00001/", "categories": "Blogging, Diary", "tags": "diary", "date": "2022-06-22 09:00:00 +0900", "snippet": " 테스트용으로 작성. 테스트용으로 작성. 테스트용으로 작성. 테스트용으로 작성.앞으로 블로그 글 잘 써보겠습니다…기존에 있던 블로그 글부터 백업해둘 예정…" } ]
